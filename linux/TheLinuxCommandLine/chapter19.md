# 第十九章: 正则表达式 #

## 19.1 什么是正则表达式 ##

正则表达式是一种符号表示法, 用于识别文本模式. 类似与匹配文件和路径时使用的 shell通配符, 但是用途更为广泛.

## 19.2 grep-文本搜索 ##

我们用来处理正则表达式的主要程序是grep, grep搜索文本文件中与指定正则表达式匹配的行, 并将结果送至标准输出.

```
# 搜索 /usr/bin下名称包含zip字符串的所有文件
ls /usr/bin | grep zip
```

grep命令的格式如下:

```
grep [options] regex [file...]
```

grep常用的选项如下表:

| 选项 | 功能描述 |
| :-- | :-- |
| -i | 忽略大小写, 同 --ignore-case |
| -v | 不匹配, 正常情况下grep会输出匹配行, 该选项可让grep 输出不匹配行, 同 --invert-match |
| -c | 输出匹配项数目而不是匹配行自身, 同 --count |
| -l | 输出匹配项文件名, 同 --files-with-matches |
| -L | 类似 -l 选项, 输出不包含匹配项的文件名, 同 --files-without-match |
| -n | 在每个匹配行前加上行号, 同 --line-number |
| -h | 进行多文件搜索时, 抑制文件名的输出, 同 --no-filename |

## 19.3 元字符和文字 ##

正则表达式 bzip 用于匹配文本中至少包含4个字符, 存在连续的按bzip顺序组成的字符串的行. 字符串bzip中的字符都是文字字符, 即它们只能与自身进行匹配.
除了文字字符, 正则表达式还可以包含用于指定更为复杂的匹配的元字符. 正则表达式的元字符包括以下字符:

```
^ $ . [ ] { } - ? * + ( ) | \
```

其他所有字符都被当作文字字符, 在极少数的情况下反斜杠字符用来创建元序列, 以及用来对元字符进行转义, 使其成为文字字符.

## 19.4 任意字符 ##

元字符中的点字符可以用于匹配任意字符.

```
grep -h '.zip' dirlist*.txt
```

## 19.5 锚 ##

插入符[\^] 和美元符号[$] 在正则表达式中被当作锚, 插入符匹配行的开头, 美元符号匹配行的末尾.

```
grep -h '^zip' dirlist*.txt
grep -h 'zip$' dirlist*.txt
grep -h '^zip$' dirlist*.txt
```

其中 [\^$] 会匹配空行.

## 19.6 中括号表达式和字符类 ##

中括号除了可以匹配正则表达式中给定位置的任意字符外, 还可以用于匹配指定字符集中的单个字符, 我们可以指定要匹配的字符集, 包括元字符的字符.

```
grep -h '[bg]zip' dirlist*.txt
```

一个字符集可以包含任意数目的字符, 并且当元字符放置到中括号中时会失去它们的特殊含义, 但是插入符在中括号中表示否定, 连字符表示字符范围.

### 19.6.1 否定 ###

如果中括号内的第一个字符是插入符, 那么剩下的字符被当作不应该在指定位置出现的字符集.

```
grep -h '[^bg]zip' dirlist*.txt
```
插入符只有在中括号表达式中是第一个字符时才代表否定符, 否则将失去特殊含义成为普通字符.

### 19.6.2 传统字符范围 ###

通过连字符可以使用三个字符来表示字符范围.

```
grep -h '^[A-Za-z0-9]' dirlist*.txt
```
当连字符出现在中括号表达式中的第一个字符时, 将失去其特殊意义成为普通字符.

### 19.6.3 POSIX字符类 ###

传统的字符范围表示方式不是所有情况的通用.

```
ls /usr/sbin/[ABCDEFGHIJKLMNOPQRSTUVWXYZ]*
ls /usr/bin/[A-Z]*
```
上述的命令在不同的系统下可能得到不同的结果.

原因是: 在UNIX开发的初期, 它只识别ASCII字符. 在ASCII字符中, 前32个字符都是控制字符, 后32个字符包含可打印字符,
接下来的32个字符包含大写字母和一些标点符号, 最后31个则包含小写字母以及更多的标点符号. ASCII系统使用如下的排序:

```
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrtsuvwxyz
```
这与通常的字典顺序不同, 字典顺序如下:

```
AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz
```

随着UNIX的普及, ASCII字符表也得到扩展, 开始使用8位二进制来表示. 为了支持这种功能, POSIX标准引入了域(locale) 的概念, 它通过不停的调整以选择特定的位置需要的字符集.
可以使用如下命令查看系统的语言设置:

```
echo $LANG
```

有了这个设置, POSIX兼容应用使用的便是字典顺序, 所以使用 [A-Z] 时的字符集是除了小写字母a之外的所有字母, 而不是预期的大写字母的合集.
为了解决这个问题, POSIX标准包含了许多标准字符类, 常用的如下表:

| 字符类 | 描述 |
|:--|:--|
| [:alnum:] | 字母字符和数字字符, 等价于 [A-Za-z0-9] |
| [:word:] | 同 [:alnum:], 多一个下划线字符 |
| [:alpha:] | 字母字符 |
| [:blank:] | 包括空格和制表符 |
| [:cntrl:] | ASCII控制码, 包含字符中的0-31以及127 |
| [:digit:] | 数字 0-9 |
| [:graph:] | 可见字符, 包含ASCII字符中的 33-126 |
| [:lower:] | 小写字母 |
| [:punct:] | 标点符号字符 |
| [:print:] | 可打印字符, 同 [:graph:] 加上空格字符 |
| [:space:] | 空白字符, 如空格, 制表符, 回车符, 换行符等 |
| [:upper:] | 大写字母 |
| [:xdigit:] | 用于表示十六进制的字符, 同 [0-9A-Fa-f] |

使用字符类重写上面的例子:

```
ls /usr/sbin/[[:upper:]]*
```

注意: 上述的并不是一个正则表达式示例, 而是shell路径名扩展的例子.

## 19.7 POSIX基本正则表达式和扩展正则表达式的比较 ##

## 19.8 或选项 ##

## 19.9 限定符 ##

### 19.9.1 ?-匹配某元素0次或1次 ###

### 19.9.2 *-匹配某元素多次或0次 ###

### 19.9.3 +-匹配某元素多次或1次 ###

### 19.9.4 {}-以指定次数匹配某元素 ###

## 19.10 正则表达式的应用 ##

### 19.10.1 用grep命令验证号码簿 ###

### 19.10.2 用find查找奇怪文件名的文件 ###

### 19.10.3 用locate查找文件 ###

### 19.10.4 利用less和vim命令搜索文件 ###

## 19.11 本章结尾语 ##
